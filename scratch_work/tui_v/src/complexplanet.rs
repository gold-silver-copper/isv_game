extern crate noise;

use noise::{core::worley::ReturnType, utils::*, *};

/// This example demonstrates how to use the noise-rs library to generate
/// terrain elevations for a complex planetary surface.
///
/// The terrain elevations are generated by a collection of over a hundred
/// noise functions in a hierarchy of groups and subgroups. Each group and
/// subgroup outputs a single output value that originates from a caching
/// module (`noise::modules::Cache`). Each group and subgroup can be thought of
/// as a single complex noise function that can be used as a source function for
/// other noise functions. The caching module was chosen as the source of the
/// output value to prevent costly recalculations by each group and subgroup
/// requesting an output value from it.
///
/// The following is a list of module groups and subgroups that build the
/// planet's terrain:
///
/// 1. Group (continent definition)
///   * Subgroup (base continent definition)
///   * Subgroup (continent definition)
/// 2. Group (terrain type definition)
///   * Subgroup (terrain type definition)
/// 3. Group (mountainous terrain)
///   * Subgroup (mountain base definition)
///   * Subgroup (high mountainous terrain)
///   * Subgroup (low mountainous terrain)
///   * Subgroup (mountainous terrain)
/// 4. Group (hilly terrain)
///   * Subgroup (hilly terrain)
/// 5. Group (plains terrain)
///   * Subgroup (plains terrain)
/// 6. Group (badlands terrain)
///   * Subgroup (badlands sand)
///   * Subgroup (badlands cliffs)
///   * Subgroup (badlands terrain)
/// 7. Group (river positions)
///   * Subgroup (river positions)
/// 8. Group (scaled mountainous terrain)
///   * Subgroup (scaled mountainous terrain)
/// 9. Group (scaled hilly terrain)
///   * Subgroup (scaled hilly terrain)
/// 10. Group (scaled plains terrain)
///   * Subgroup (scaled plains terrain)
/// 11. Group (scaled badlands terrain)
///   * Subgroup (scaled badlands terrain)
/// 12. Group (final planet)
///   * Subgroup (continental shelf)
///   * Subgroup (base continent elevation)
///   * Subgroup (continents with plains)
///   * Subgroup (continent with hills)
///   * Subgroup (continents with mountains)
///   * Subgroup (continents with badlands)
///   * Subgroup (continents with rivers)
///   * Subgroup (unscaled final planet)
///   * Subgroup (final planet)
///
/// A description for each group and subgroup can be found above the source
/// code for that group and subgroup.
#[allow(non_snake_case)]
pub fn gen_world() -> NoiseMap {
    /// Planet seed. Change this to generate a different planet.
    const CURRENT_SEED: u32 = 0;

    /// Frequency of the planet's continents. Higher frequency produces
    /// smaller, more numerous continents. This value is measured in radians.
    const CONTINENT_FREQUENCY: f64 = 1.0;

    /// Lacunarity of the planet's continents. Changing this value produces
    /// slightly different continents. For the best results, this value should
    /// be random, but close to 2.0.
    const CONTINENT_LACUNARITY: f64 = 2.208984375;

    /// Lacunarity of the planet's mountains. Changing the value produces
    /// slightly different mountains. For the best results, this value should
    /// be random, but close to 2.0.
    const MOUNTAIN_LACUNARITY: f64 = 2.142578125;

    /// Lacunarity of the planet's hills. Changing this value produces
    /// slightly different hills. For the best results, this value should be
    /// random, but close to 2.0.
    const HILLS_LACUNARITY: f64 = 2.162109375;

    /// Lacunarity of the planet's plains. Changing this value produces
    /// slightly different plains. For the best results, this value should be
    /// random, but close to 2.0.
    const PLAINS_LACUNARITY: f64 = 2.314453125;

    /// Lacunarity of the planet's badlands. Changing this value produces
    /// slightly different badlands. For the best results, this value should
    /// be random, but close to 2.0.
    const BADLANDS_LACUNARITY: f64 = 2.212890625;

    /// Specifies the "twistiness" of the mountains.
    const MOUNTAINS_TWIST: f64 = 1.0;

    /// Specifies the "twistiness" of the hills.
    const HILLS_TWIST: f64 = 1.0;

    /// Specifies the "twistiness" of the badlands.
    const BADLANDS_TWIST: f64 = 1.0;

    /// Specifies the planet's sea level. This value must be between -1.0
    /// (minimum planet elevation) and +1.0 (maximum planet elevation).
    const SEA_LEVEL: f64 = 0.0;

    /// Specifies the level on the planet in which continental shelves appear.
    /// This value must be between -1.0 (minimum planet elevation) and +1.0
    /// (maximum planet elevation), and must be less than `SEA_LEVEL`.
    const SHELF_LEVEL: f64 = -0.375;

    /// Determines the amount of mountainous terrain that appears on the
    /// planet. Values range from 0.0 (no mountains) to 1.0 (all terrain is
    /// covered in mountains). Mountains terrain will overlap hilly terrain.
    /// Because the badlands terrain may overlap parts of the mountainous
    /// terrain, setting `MOUNTAINS_AMOUNT` to 1.0 may not completely cover the
    /// terrain in mountains.
    const MOUNTAINS_AMOUNT: f64 = 0.5;

    /// Determines the amount of hilly terrain that appears on the planet.
    /// Values range from 0.0 (no hills) to 1.0 (all terrain is covered in
    /// hills). This value must be less than `MOUNTAINS_AMOUNT`. Because the
    /// mountains terrain will overlap parts of the hilly terrain, and the
    /// badlands terrain may overlap parts of the hilly terrain, setting
    /// `HILLS_AMOUNT` to 1.0 may not completely cover the terrain in hills.
    const HILLS_AMOUNT: f64 = (1.0 + MOUNTAINS_AMOUNT) / 2.0;

    /// Determines the amount of badlands terrain that covers the planet.
    /// Values range from 0.0 (no badlands) to 1.0 (all terrain is covered in
    /// badlands). Badlands terrain will overlap any other type of terrain.
    const BADLANDS_AMOUNT: f64 = 0.3125;

    /// Offset to apply to the terrain type definition. Low values (< 1.0)
    /// cause the rough areas to appear only at high elevations. High values
    /// (> 2.0) cause the rough areas to appear at any elevation. The
    /// percentage of rough areas on the planet are independent of this value.
    const TERRAIN_OFFSET: f64 = 1.0;

    /// Specifies the amount of "glaciation" on the mountains. This value
    /// should be close to 1.0 and greater than 1.0.
    const MOUNTAIN_GLACIATION: f64 = 1.375;

    /// Scaling to apply to the base continent elevations, in planetary
    /// elevation units.
    const CONTINENT_HEIGHT_SCALE: f64 = (1.0 - SEA_LEVEL) / 4.0;

    /// Maximum depth of the rivers, in planetary elevation units.
    const RIVER_DEPTH: f64 = 0.0234375;

    // ////////////////////////////////////////////////////////////////////////
    // Function group: continent definition
    // ////////////////////////////////////////////////////////////////////////

    // ////////////////////////////////////////////////////////////////////////
    // Function subgroup: base continent definition (7 noise functions)
    //
    // This subgroup roughly defines the positions and base elevations of the
    // planet's continents.
    //
    // The "base elevation" is the elevation of the terrain before any terrain
    // features (mountains, hills, etc.) are placed on that terrain.
    //
    // -1.0 represents the lowest elevations and +1.0 represents the highest
    // elevations.
    //
    fn baseContinentDef() -> impl NoiseFn<f64, 3> {
        // 1: [Continent module]: This FBM module generates the continents. This
        // noise function has a high number of octaves so that detail is visible at
        // high zoom levels.
        let baseContinentDef_fb0 = Fbm::<Perlin>::new(CURRENT_SEED)
            .set_frequency(CONTINENT_FREQUENCY)
            .set_persistence(0.5)
            .set_lacunarity(CONTINENT_LACUNARITY)
            .set_octaves(14);

        //    debug::render_noise_module("complexplanet_images/00_0_baseContinentDef_fb0\
        //    .png",
        //                               &baseContinentDef_fb0,
        //                               1024,
        //                               1024,
        //                               100);

        // 2: [Continent-with-ranges module]: Next, a curve module modifies the
        // output value from the continent module so that very high values appear
        // near sea level. This defines the positions of the mountain ranges.
        let baseContinentDef_cu = Curve::new(baseContinentDef_fb0)
            .add_control_point(-2.0000 + SEA_LEVEL, -1.625 + SEA_LEVEL)
            .add_control_point(-1.0000 + SEA_LEVEL, -1.375 + SEA_LEVEL)
            .add_control_point(0.0000 + SEA_LEVEL, -0.375 + SEA_LEVEL)
            .add_control_point(0.0625 + SEA_LEVEL, 0.125 + SEA_LEVEL)
            .add_control_point(0.1250 + SEA_LEVEL, 0.250 + SEA_LEVEL)
            .add_control_point(0.2500 + SEA_LEVEL, 1.000 + SEA_LEVEL)
            .add_control_point(0.5000 + SEA_LEVEL, 0.250 + SEA_LEVEL)
            .add_control_point(0.7500 + SEA_LEVEL, 0.250 + SEA_LEVEL)
            .add_control_point(1.0000 + SEA_LEVEL, 0.500 + SEA_LEVEL)
            .add_control_point(2.0000 + SEA_LEVEL, 0.500 + SEA_LEVEL);

        //    debug::render_noise_module("complexplanet_images/00_1_baseContinentDef_cu\
        //    .png",
        //                               &baseContinentDef_cu,
        //                               1024,
        //                               1024,
        //                               100);

        // 3: [Carver module]: This higher-frequency BasicMulti module will be
        // used by subsequent noise functions to carve out chunks from the
        // mountain ranges within the continent-with-ranges module so that the
        // mountain ranges will not be completely impassible.
        let baseContinentDef_fb1 = Fbm::<Perlin>::new(CURRENT_SEED + 1)
            .set_frequency(CONTINENT_FREQUENCY * 4.34375)
            .set_persistence(0.5)
            .set_lacunarity(CONTINENT_LACUNARITY)
            .set_octaves(11);

        //    debug::render_noise_module("complexplanet_images/00_2_baseContinentDef_fb1\
        //    .png",
        //                               &baseContinentDef_fb1,
        //                               1024,
        //                               1024,
        //                               100);

        // 4: [Scaled-carver module]: This scale/bias module scales the output
        // value from the carver module such that it is usually near 1.0. This
        // is required for step 5.
        let baseContinentDef_sb = ScaleBias::new(baseContinentDef_fb1)
            .set_scale(0.375)
            .set_bias(0.625);

        //    debug::render_noise_module("complexplanet_images/00_3_baseContinentDef_sb\
        //    .png",
        //                               &baseContinentDef_sb,
        //                               1024,
        //                               1024,
        //                               100);

        // 5: [Carved-continent module]: This minimum-value module carves out
        // chunks from the continent-with-ranges module. it does this by ensuring
        // that only the minimum of the output values from the scaled-carver
        // module and the continent-with-ranges module contributes to the output
        // value of this subgroup. Most of the time, the minimum value module will
        // select the output value from the continent-with-ranges module since the
        // output value from the scaled-carver is usually near 1.0. Occasionally,
        // the output from the scaled-carver module will be less than the output
        // value from the continent-with-ranges module, so in this case, the output
        // value from the scaled-carver module is selected.
        let baseContinentDef_mi = Min::new(baseContinentDef_sb, baseContinentDef_cu);

        //    debug::render_noise_module("complexplanet_images/00_4_baseContinentDef_mi\
        //    .png",
        //                               &baseContinentDef_mi,
        //                               1024,
        //                               1024,
        //                               100);

        // 6: [Clamped-continent module]: Finally, a clamp module modifies the
        // carved continent module to ensure that the output value of this subgroup
        // is between -1.0 and 1.0.
        let baseContinentDef_cl = Clamp::new(baseContinentDef_mi).set_bounds(-1.0, 1.0);

        // 7: [Base-continent-definition subgroup]: Caches the output value from
        // the clamped-continent module.
        let baseContinentDef = Cache::new(baseContinentDef_cl);

        baseContinentDef
    }

    //    debug::render_noise_module("complexplanet_images/00_5_baseContinentDef.png",
    //                               &baseContinentDef,
    //                               1024,
    //                               1024,
    //                               100);

    // ////////////////////////////////////////////////////////////////////////
    // Function subgroup: continent definition (5 noise functions)
    //
    // This subgroup warps the output value from the base-continent-definition
    // subgroup, producing more realistic terrain.
    //
    // Warping the base continent definition produces lumpier terrain with
    // cliffs and rifts.
    //
    // -1.0 represents the lowest elevations and +1.0 represents the highest
    // elevations.
    //

    // 1: [Coarse-turbulence module]: This turbulence module warps the output
    // value from the base-continent-definition subgroup, adding some coarse
    // detail to it.
    let continentDef_tu0 = Turbulence::<_, Perlin>::new(baseContinentDef())
        .set_seed(CURRENT_SEED + 10)
        .set_frequency(CONTINENT_FREQUENCY * 15.25)
        .set_power(CONTINENT_FREQUENCY / 113.75)
        .set_roughness(13);

    //    debug::render_noise_module("complexplanet_images/01_0_continentDef_tu0.png",
    //                               &continentDef_tu0,
    //                               1024,
    //                               1024,
    //                               1000);

    // 2: [Intermediate-turbulence module]: This turbulence module warps the
    // output value from the coarse-turbulence module. This turbulence has a
    // higher frequency, but lower power, than the coarse-turbulence module,
    // adding some intermediate detail to it.
    let continentDef_tu1 = Turbulence::<_, Perlin>::new(continentDef_tu0)
        .set_seed(CURRENT_SEED + 11)
        .set_frequency(CONTINENT_FREQUENCY * 47.25)
        .set_power(CONTINENT_FREQUENCY / 433.75)
        .set_roughness(12);

    //    debug::render_noise_module("complexplanet_images/01_1_continentDef_tu1.png",
    //                               &continentDef_tu1,
    //                               1024,
    //                               1024,
    //                               1000);

    // 3: [Warped-base-continent-definition module]: This turbulence module
    // warps the output value from the intermediate-turbulence module. This
    // turbulence has a higher frequency, but lower power, than the
    // intermediate-turbulence module, adding some fine detail to it.
    let continentDef_tu2 = Turbulence::<_, Perlin>::new(continentDef_tu1)
        .set_seed(CURRENT_SEED + 12)
        .set_frequency(CONTINENT_FREQUENCY * 95.25)
        .set_power(CONTINENT_FREQUENCY / 1019.75)
        .set_roughness(11);

    //    debug::render_noise_module("complexplanet_images/01_2_continentDef_tu2.png",
    //                               &continentDef_tu2,
    //                               1024,
    //                               1024,
    //                               1000);

    // 4: [Select-turbulence module]: At this stage, the turbulence is applied
    // to the entire base-continent-definition subgroup, producing some very
    // rugged, unrealistic coastlines.  This selector module selects the
    // output values from the (unwarped) base-continent-definition subgroup
    // and the warped-base-continent-definition module, based on the output
    // value from the (unwarped) base-continent-definition subgroup.  The
    // selection boundary is near sea level and has a relatively smooth
    // transition.  In effect, only the higher areas of the base-continent-
    // definition subgroup become warped; the underwater and coastal areas
    // remain unaffected.
    let continentDef_se = Select::new(baseContinentDef(), continentDef_tu2, baseContinentDef())
        .set_bounds(SEA_LEVEL - 0.0375, SEA_LEVEL + 1000.0375)
        .set_falloff(0.0625);

    //    debug::render_noise_module("complexplanet_images/01_3_continentDef_se.png",
    //                               &continentDef_se,
    //                               1024,
    //                               1024,
    //                               1000);

    // 5: [Continent-definition group]: Caches the output value from the
    // clamped-continent module. This is the output value for the entire
    // continent-definition group.
    let continentDef = Cache::new(continentDef_se);

    //    debug::render_noise_module("complexplanet_images/01_4_continentDef.png",
    //                               &continentDef,
    //                               1024,
    //                               1024,
    //                               1000);

    // ////////////////////////////////////////////////////////////////////////
    // Function group: terrain type definition
    // ////////////////////////////////////////////////////////////////////////

    // ////////////////////////////////////////////////////////////////////////
    // Function subgroup: terrain type definition (3 noise functions)
    //
    // This subgroup defines the positions of the terrain types on the planet.
    //
    // Terrain types include, in order of increasing roughness, plains, hills,
    // and mountains.
    //
    // This subgroup's output value is based on the output value from the
    // continent-definition group. Rougher terrain mainly appears at higher
    // elevations.
    //
    // -1.0 represents the smoothest terrain types (plains and underwater) and
    // +1.0 represents the roughest terrain types (mountains).
    //

    // 1: [Warped-continent module]: This turbulence module slightly warps the
    // output value from the continent-definition group. This prevents the
    // rougher terrain from appearing exclusively at higher elevations. Rough
    // areas may now appear in the the ocean, creating rocky islands and
    // fjords.
    let terrainTypeDef_tu = Turbulence::<_, Perlin>::new(&continentDef)
        .set_seed(CURRENT_SEED + 20)
        .set_frequency(CONTINENT_FREQUENCY * 18.125)
        .set_power(CONTINENT_FREQUENCY / 20.59375 * TERRAIN_OFFSET)
        .set_roughness(3);

    // 2: [Roughness-probability-shift module]: This terracing module sharpens
    // the edges of the warped-continent module near sea level and lowers the
    // slope towards the higher-elevation areas. This shrinks the areas in
    // which the rough terrain appears, increasing the "rarity" of rough
    // terrain.
    let terrainTypeDef_te = Terrace::new(terrainTypeDef_tu)
        .add_control_point(-1.00)
        .add_control_point(SHELF_LEVEL + SEA_LEVEL / 2.0)
        .add_control_point(1.00);

    // 3: [Terrain-type-definition group]: Caches the output value from the
    // roughness-probability-shift module. This is the output value for the
    // entire terrain-type-definition group.
    let terrainTypeDef = Cache::new(terrainTypeDef_te);

    // /////////////////////////////////////////////////////////////////////////
    // Function group: mountainous terrain
    // /////////////////////////////////////////////////////////////////////////

    // /////////////////////////////////////////////////////////////////////////
    // Function subgroup: mountain base definition (9 noise functions)
    //
    // This subgroup generates the base-mountain elevations. Other subgroups
    // will add the ridges and low areas to the base elevations.
    //
    // -1.0 represents low mountainous terrain and +1.0 represents high
    // mountainous terrain.
    //

    // 1: [Mountain-ridge module]: This ridged-multifractal-noise function
    // generates the mountain ridges.
    let mountainBaseDef_rm0 = RidgedMulti::<Perlin>::new(CURRENT_SEED + 30)
        .set_frequency(1723.0)
        .set_lacunarity(MOUNTAIN_LACUNARITY)
        .set_octaves(4);

    // 2: [Scaled-mountain-ridge module]: Next, a scale/bias module scales the
    // output value from the mountain-ridge module so that its ridges are not
    // too high. The reason for this is that another subgroup adds actual
    // mountainous terrain to these ridges.

    // 3: [Low-mountainous-terrain module]: This multiplication module combines
    // the output values from the two ridged-multifractal-noise functions. This
    // causes the following to appear in the resulting terrain:
    // - Cracks appear when two negative output values are multiplied together.
    // - Flat areas appear when a positive and a negative output value are
    //   multiplied together.

    // /////////////////////////////////////////////////////////////////////////
    // Function subgroup: mountainous terrain (7 noise functions)
    //
    // This subgroup generates the final mountainous terrain by combining the
    // high-mountainous-terrain subgroup with the low-mountainous-terrain
    // subgroup.
    //
    // -1.0 represents the lowest elevations and +1.0 represents the highest
    // elevations.
    //

    let noise_map = PlaneMapBuilder::new(&mountainBaseDef_rm0)
        .set_size(1024, 1024)
        .set_x_bounds(-2.0, 2.0)
        .set_y_bounds(-2.0, 2.0)
        .build();
    noise_map
}
